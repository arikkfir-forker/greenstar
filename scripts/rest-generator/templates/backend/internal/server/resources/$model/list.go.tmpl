// Code generated by greenstar scripts; DO NOT EDIT.

package {{ .model.Name | toSnake }}

{{- if .model.List }}

import (
	"errors"
	"fmt"
	"github.com/arikkfir/greenstar/backend/internal/server/util"
	"github.com/arikkfir/greenstar/backend/internal/util/lang"
	"github.com/arikkfir/greenstar/backend/internal/util/observability"
	"github.com/shopspring/decimal"
	"strconv"
	"strings"
	"net/http"
	"slices"
	"time"
)

var (
	_ = decimal.Decimal{}
	_ = time.Time{}
)

var (
	sortableColumns = []string{
		{{- range $name, $p := .model.Properties }}
		{{- if $p.Sortable }}"{{ $name | toLowerCamelCase }}",{{- end }}
		{{- end }}
	}
)

type ListRequest struct {
	properties  []string
	Offset  *uint `url:"_offset,omitempty"`
	Count   *uint `url:"_count,omitempty"`
	Sort []string `url:"_sort,omitempty"`
	{{- range $name, $f := .model.List.Filters }}
	{{ $name }} *{{ $f.Type.GoType }} `url:"{{ $name | toLowerCamelCase }},omitempty"`
	{{- end }}
	{{- range $name, $p := .model.List.Parameters }}
	{{ $name }} {{ if not $p.Required }}*{{ end }}{{ $p.Type.GoType }} `url:"{{ $name | toLowerCamelCase }},omitempty"`
	{{- end }}
}

{{- range $name, $p := .model.List.Filters }}
func (lr *ListRequest) Has{{ $name }}() bool { return slices.Contains(lr.properties, "{{ $name | toLowerCamelCase }}") }
{{- end }}
{{- range $name, $p := .model.List.Parameters }}
{{- if not $p.Required }}
func (lr *ListRequest) Has{{ $name }}() bool { return slices.Contains(lr.properties, "{{ $name | toLowerCamelCase }}") }
{{- end }}
{{- end }}
func (lr *ListRequest) UnmarshalFromRequest(r *http.Request) error {
	lr.properties = nil

	values := r.Form

	{{- range $name, $p := .model.List.Filters }}
	if values.Has("{{ $name | toLowerCamelCase }}") {
		lr.properties = append(lr.properties, "{{ $name | toLowerCamelCase }}")
		if rawValue := values.Get("{{ $name | toLowerCamelCase }}"); rawValue == util.QueryNilValue {
			{{- if .Required }}
			return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "{{ $name | toLowerCamelCase }}")
			{{- else }}
			lr.{{ $name }} = nil
			{{- end }}
		} else {
			sv := {{ if $p.Required }}rawValue{{ else }}lang.PtrOf(rawValue){{ end }}
			{{- if eq $p.Type.GoType "string" }}
			lr.{{ $name }} = sv
			{{- else if eq $p.Type.GoType "time.Time" }}
			if tv, err := time.Parse(time.RFC3339, {{ if not $p.Required }}*{{ end }}sv); err != nil {
				return err
			} else {
				lr.{{ $name }} = {{ if not $p.Required }}lang.PtrOf(tv){{ else }}tv{{ end }}
			}
			{{- else if eq $p.Type.GoType "decimal.Decimal" }}
			if dv, err := decimal.NewFromString({{ if not $p.Required }}*{{ end }}sv); err != nil {
				return err
			} else {
				lr.{{ $name }} = {{ if not $p.Required }}lang.PtrOf(dv){{ else }}dv{{ end }}
			}
			{{- else }}
			{{ fail "unsupported property type encountered in list filter property '%s' in model '%s': %s" $name $.model.Name $p.Type.GoType }}
			{{- end }}
		}
	{{- if $p.Required }}
	} else {
		return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "{{ $name | toLowerCamelCase }}")
	{{- end }}
	}
	{{- end }}

	{{- range $name, $p := .model.List.Parameters }}
	if values.Has("{{ $name | toLowerCamelCase }}") {
		lr.properties = append(lr.properties, "{{ $name | toLowerCamelCase }}")
		if rawValue := values.Get("{{ $name | toLowerCamelCase }}"); rawValue == util.QueryNilValue {
			{{- if .Required }}
			return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "{{ $name | toLowerCamelCase }}")
			{{- else }}
			lr.{{ $name }} = nil
			{{- end }}
		} else {
			sv := {{ if $p.Required }}rawValue{{ else }}lang.PtrOf(rawValue){{ end }}
			{{- if eq $p.Type.GoType "string" }}
			lr.{{ $name }} = sv
			{{- else if eq $p.Type.GoType "time.Time" }}
			if tv, err := time.Parse(time.RFC3339, {{ if not $p.Required }}*{{ end }}sv); err != nil {
				return err
			} else {
				lr.{{ $name }} = {{ if not $p.Required }}lang.PtrOf(tv){{ else }}tv{{ end }}
			}
			{{- else if eq $p.Type.GoType "decimal.Decimal" }}
			if dv, err := decimal.NewFromString({{ if not $p.Required }}*{{ end }}sv); err != nil {
				return err
			} else {
				lr.{{ $name }} = {{ if not $p.Required }}lang.PtrOf(dv){{ else }}dv{{ end }}
			}
			{{- else }}
			{{ fail "unsupported property type encountered in list filter property '%s' in model '%s': %s" $name $.model.Name $p.Type.GoType }}
			{{- end }}
		}
	{{- if $p.Required }}
	} else {
		return fmt.Errorf("%w: '%s' is required", util.ErrBadRequest, "{{ $name | toLowerCamelCase }}")
	{{- end }}
	}
	{{- end }}

	lr.Offset = nil
	if values.Has("_offset") {
		if v, err := strconv.ParseUint(values.Get("_offset"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid offset '%s'", util.ErrBadRequest, values.Get("_offset"))
		} else {
			lr.Offset = lang.PtrOf(uint(v))
		}
	}

	lr.Count = nil
	if values.Has("_count") {
		if v, err := strconv.ParseUint(values.Get("_count"), 0, 0); err != nil {
			return fmt.Errorf("%w: invalid count '%s'", util.ErrBadRequest, values.Get("_count"))
		} else {
			lr.Count = lang.PtrOf(uint(v))
		}
	}

	lr.Sort = nil
	if values.Has("_sort") {
		if sort := values.Get("_sort"); sort != "" {
			lr.Sort = strings.Split(sort, ",")
			for _, s := range lr.Sort {
				sortTokens := strings.Split(s, ":")
				var col, dir string
				if len(sortTokens) == 1 {
					col = sortTokens[0]
					dir = "asc"
				} else if len(sortTokens) == 2 {
					col = sortTokens[0]
					dir = strings.ToLower(sortTokens[1])
				} else {
					return fmt.Errorf("%w: invalid sort spec '%s'", util.ErrBadRequest, s)
				}
				if dir != "asc" && dir != "desc" {
					return fmt.Errorf("%w: invalid sort direction in '%s'", util.ErrBadRequest, s)
				} else if !slices.Contains(sortableColumns, col) {
					return fmt.Errorf("%w: column '%s' is not sortable", util.ErrBadRequest, col)
				}
			}
		}
	}

	return nil
}

type ListResponse struct {
	TotalCount uint      `json:"totalCount"`
	Items      []{{ .model.Name }} `json:"items"`
}

func (s *Server) List(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	l := observability.GetLogger(ctx)

	{{- if gt (len .model.List.Permissions) 0 }}
	if err := util.VerifyPermissions(ctx, {{ .model.List.Permissions | strings }}); err != nil {
		util.ServeError(w, r, err)
		return
	}
	{{- end }}

	if err := r.ParseForm(); err != nil {
		util.ServeError(w, r, errors.Join(util.ErrBadRequest, err))
		return
	}

	req := ListRequest{}
	if err := req.UnmarshalFromRequest(r); err != nil {
		util.ServeError(w, r, err)
		return
	}

	res, err := s.h.List(ctx, req)
	if err != nil {
		if code := util.ServeError(w, r, err); code >= http.StatusInternalServerError {
			l.ErrorContext(ctx, "Failed listing {{ .model.Name | toPlural | lower }}", "err", err)
		}
		return
	}

	type ResponseWithOffset struct {
		Offset *uint      `json:"offset,omitempty"`
		ListResponse
	}

	resWithOffset := ResponseWithOffset{
		Offset: req.Offset,
		ListResponse: *res,
	}
	if err := util.Marshal(w, r, http.StatusOK, resWithOffset); err != nil {
		l.ErrorContext(ctx, "Failed marshaling {{ .model.Name | toPlural | lower }}", "err", err)
		util.ServeError(w, r, err)
	}
}

{{- end }}
